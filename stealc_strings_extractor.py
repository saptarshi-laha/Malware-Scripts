def xor_decrypt(xor_key, enc_string, size):
    decrypted = bytearray()
    key_len = len(xor_key)
    for i in range(size):
        decrypted.append(enc_string[i] ^ xor_key[i % key_len])
    return decrypted

decryption_function = None
symbols = bv.get_symbols_by_name("decryption")
if symbols:
    decryption_function = bv.get_function_at(symbols[0].address)

if decryption_function is None:
    print("Decryption function not found!")
else:
    decrypted_strings = []
    for func in bv.functions:
        for block in func.medium_level_il:
            for instr in block:
                if instr.operation == MediumLevelILOperation.MLIL_CALL:
                    if isinstance(instr.dest, MediumLevelILConstPtr) and instr.dest.constant == decryption_function.start:
                        try:
                            xor_key_addr = instr.params[0].constant
                            enc_string_addr = instr.params[1].constant
                            size = instr.params[2].constant

                            xor_key_bytes = bv.read(xor_key_addr, size)
                            encrypted_bytes = bv.read(enc_string_addr, size)

                            if xor_key_bytes and encrypted_bytes:
                                decrypted = xor_decrypt(xor_key_bytes, encrypted_bytes, size)
                                decrypted_strings.append(decrypted.decode('utf-8', errors='ignore'))

                        except Exception as e:
                            print(f"Error processing call at address {hex(instr.address)}: {e}")
                            continue

    if decrypted_strings:
        for i, dec_string in enumerate(decrypted_strings):
            print(f"Decrypted String {i}: {dec_string}")
    else:
        print("No decrypted strings found.")
